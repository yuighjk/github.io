{
    "version": "https://jsonfeed.org/version/1",
    "title": "FeiFei • All posts by \"npm\" tag",
    "description": "FeiFei 的博客",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/13/npm-yarn-pnpm-cnpm-dui-bi-qi-you-lie-shi/",
            "url": "http://example.com/2022/10/13/npm-yarn-pnpm-cnpm-dui-bi-qi-you-lie-shi/",
            "title": "npm、yarn、pnpm、cnpm对比其优劣势",
            "date_published": "2022-10-13T02:59:36.659Z",
            "content_html": "<span id=\"more\"></span>\n\n<h1 id=\"npm，yarn，cnpm，pnpm的介绍\"><a href=\"#npm，yarn，cnpm，pnpm的介绍\" class=\"headerlink\" title=\"npm，yarn，cnpm，pnpm的介绍\"></a>npm，yarn，cnpm，pnpm的介绍</h1><h2 id=\"npm\"><a href=\"#npm\" class=\"headerlink\" title=\"npm\"></a>npm</h2><p>首先说一下Node.js，简单的说 Node.js 就是运行在服务端的 JavaScript。node通过更改连接到服务器的方式，可以处理高并发任务。</p>\n<p>npm:   nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）</p>\n<p>npm使用一个名为<code>package.json</code>的文件，用户可以通过<code>npm install --save</code>命令把项目里所有的依赖项保存在这个文件里。</p>\n<p>npm安装速度慢的一个重要原因：npm远程服务器在国外，必须首先遍历所有的项目依赖关系，然后再决定如何生成扁平化的node_modules结构。不过，npm有本地缓存，它保存了已经下载的每个版本的压缩包，缓存可以减少安装时间。</p>\n<h3 id=\"安装单个npm包：\"><a href=\"#安装单个npm包：\" class=\"headerlink\" title=\"安装单个npm包：\"></a>安装单个npm包：</h3><p><img src=\"https://img-blog.csdnimg.cn/44a32bd7c0ee45c59138fb827c5e4f2d.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eUZR2oLH-1665560508928)(https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c9054e9a-47b2-4488-b489-6d14c1dc0204/Untitled.png)]\"></p>\n<p>devDependencies：通常是开发的工具（eg:测试用的库），开发环境的依赖</p>\n<p>dependencies：与生产环境中应用程序相关的</p>\n<p>两者的区别在普通项目中，两者都安装，程序才能跑起来（因为devDependencies一般包含程序运行环境依赖）；纯node项目，只安装dependencies就可以运行项目了，而安装了 <code>devDependencies</code>后，就会让编辑器的 <code>eslint</code>检测插件开始工作，或者是可以用 <code>jest</code>进行单元测试：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b78398b007e94877984683bb522f8fdb.png\" alt=\"[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eGIiHojD-1665560508929)(https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6e8634cc-3f12-42f8-845f-325913194496/Untitled.png)]\"></p>\n<p>是真正意义上的开发环境与生产环境分离。</p>\n<h3 id=\"npm使用方法：\"><a href=\"#npm使用方法：\" class=\"headerlink\" title=\"npm使用方法：\"></a>npm使用方法：</h3><p>第一种：</p>\n<p>直接安装cnpm 安装淘宝提供的cnpm，并更改服务器地址为淘宝的国内地址， 命令：</p>\n<p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>，以后安装直接采用<code>cpm</code>替代<code>npm</code>， 例如原生npm命令为：<code>npm install uniq --save</code>，cnpm命令为：<code>cnpm install uniq --save</code></p>\n<p>第二种：</p>\n<p>替换npm仓库地址为淘宝镜像地址（推荐） 命令：<code>npm config set registry https://registry.npm.taobao.org</code>， 查看是否更改成功：<code>npm config get registry</code>，以后安装时，依然用npm命令，但是实际是从淘宝国内服务器下载的</p>\n<h2 id=\"yarn\"><a href=\"#yarn\" class=\"headerlink\" title=\"yarn\"></a>yarn</h2><p><a href=\"https://yarn.bootcss.com/docs/install/#windows-stable\">安装 | Yarn 中文文档 (bootcss.com)</a></p>\n<p>快速、可靠、安全的依赖管理工具。</p>\n<p>一开始是为了解决由于语义版本控制而导致npm安装的不确定的问题，每次安装都生成<code>yarn.lock</code>文件，<code>yarn.lock</code><br>文件还包含要安装的内容的校验和，以确保使用的库的版本相同。</p>\n<h3 id=\"yarn的改进：\"><a href=\"#yarn的改进：\" class=\"headerlink\" title=\"yarn的改进：\"></a>yarn的改进：</h3><p>运行速度得到了显著的提升</p>\n<p>像npm一样，yarn使用本地缓存。与npm不同的是，yarn无需互联网连接就能安装本地缓存的依赖项，它提供了<strong>离线模式</strong></p>\n<h3 id=\"yarn的workspace\"><a href=\"#yarn的workspace\" class=\"headerlink\" title=\"yarn的workspace\"></a>yarn的workspace</h3><p>Yarn Workspaces（工作区）是Yarn提供的<code>monorepo</code>的依赖管理机制，从Yarn 1.0开始默认支持，用于在代码仓库的根目录下管理多个package的依赖。</p>\n<p>Workspace 能更好的统一管理有多个项目的仓库，既可在每个项目下使用独立的 package.json 管理依赖，又可便利的享受一条 yarn命令安装或者升级所有依赖等。更重要的是可以使多个项目共享同一个 <code>node_modules</code>目录，提升开发效率和降低磁盘空间占用。</p>\n<h2 id=\"pnpm\"><a href=\"#pnpm\" class=\"headerlink\" title=\"pnpm\"></a>pnpm</h2><p><a href=\"https://pnpm.io/\">Fast, disk space efficient package manager | pnpm官网</a></p>\n<p>全称是 “Performant NPM”，即高性能的 npm。利用硬链接和符号链接来避免复制本地缓存源文件，继承了yarn的所有优点，包括离线模式和确定性安装</p>\n<h3 id=\"特点：速度快，节约磁盘空间，安全性高\"><a href=\"#特点：速度快，节约磁盘空间，安全性高\" class=\"headerlink\" title=\"特点：速度快，节约磁盘空间，安全性高\"></a>特点：速度快，节约磁盘空间，安全性高</h3><h3 id=\"高效利用磁盘空间\"><a href=\"#高效利用磁盘空间\" class=\"headerlink\" title=\"高效利用磁盘空间\"></a>高效利用磁盘空间</h3><p>内部基于内容寻址的文件系统存储磁盘上所有的文件：</p>\n<p>这个文件好处在于：</p>\n<p>1.不会重复安装同一个包。设想一下，假如公司的每个项目都用了 vue 全家桶，那么每个项目都需要安装 vue、vue-router、vuex、axios 等几乎相同的库，如果有 100 个项目，那就要重复安装 100 遍！！非常耗费磁盘空间。</p>\n<p>2.即使包的不同版本，pnpm也会极大程度的复用之前版本的代码。举个例子，比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 <code>hardlink</code>，仅仅写入那<code>一个新增的文件</code>。</p>\n<h3 id=\"支持-monorepo\"><a href=\"#支持-monorepo\" class=\"headerlink\" title=\"支持 monorepo\"></a>支持 monorepo</h3><p>对于多个项目的管理，一般用多个git仓库。但是monorepo的宗旨就是用一个git仓库管理多个子项目，所有子项目都存放在根目录的<code>packages</code>目录下，那么一个子项目就代表一个<code>package</code></p>\n<p>如果你之前没接触过 monorepo 的概念，建议仔细看看<a href=\"https://link.juejin.cn/?target=https://www.perforce.com/blog/vcs/what-monorepo\">这篇文章</a>以及开源的 monorepo 管理工具<a href=\"https://link.juejin.cn/?target=https://github.com/lerna/lerna%23readme\">lerna</a>，项目目录结构可以参考一下 <a href=\"https://link.juejin.cn/?target=https://github.com/babel/babel\">babel 仓库</a>。</p>\n<p>pnpm还保留了非扁平化的node_modules文件夹，避免了扁平化node_modules都带来的幻影依赖，依赖分身的问题。</p>\n<p>安装可以使用npm安装：npm i -g pnpm</p>\n<h3 id=\"pnpm-的-node-modules\"><a href=\"#pnpm-的-node-modules\" class=\"headerlink\" title=\"pnpm 的 node_modules\"></a>pnpm 的 node_modules</h3><p>与依赖提升和扁平化的 node_modules 不同，pnpm 引入了另一套依赖管理策略：<a href=\"https://cloud.tencent.com/developer/article/2047247\">内容寻址存储</a>。</p>\n<h2 id=\"cnpm\"><a href=\"#cnpm\" class=\"headerlink\" title=\"cnpm\"></a>cnpm</h2><p>与npm用法完全一致</p>\n<p>npm安装插件是从国外服务器下载，受网络影响大，可能出现异常。淘宝为我们搭建了一个国内的npm服务器cnpm，它目前是每隔10分钟将国外npm仓库的所有内容“搬运”回国内的服务器上，这样我们直接访问淘宝的国内服务器就可以了.</p>\n<ol>\n<li><p>cnpm 比 npm 快多了</p>\n</li>\n<li><p>cnpm 没有 package-lock.json</p>\n</li>\n</ol>\n<p><code>cnpm</code>最大的隐患：安装时不会产生 <code>package-lock.json</code>，并且项目中即使有 <code>package-lock.json</code>，<code>cnpm</code>也是不管不顾的，只读取 <code>package.json</code>。阿hi有一个因哈UN就是用的包不一定遵循<code>Semver</code>规范。</p>\n<ol start=\"3\">\n<li>有些依赖包用不了</li>\n</ol>\n<p>有些依赖包用 cnpm 安装就不能用，用 npm 安装就可以用，这个问题估计和 <code>cnpm</code>包的使用软链接的方式有关系（并不确定）。</p>\n<p>cnpm 和 npm 混用，导致包挂了，这个可以确定是 <code>cnpm</code>使用软链接的问题。所以，还是尽量不要混用吧。</p>\n<p>能用 npm 最好用 npm，公司内部的 <code>私有镜像源</code>也建议做成 <code>npm</code>，毕竟 <code>cnpm</code> 还是存在一些隐患。</p>\n<h2 id=\"扁平化的node-modules\"><a href=\"#扁平化的node-modules\" class=\"headerlink\" title=\"扁平化的node_modules\"></a>扁平化的node_modules</h2><pre><code>node_modules\n├── A\n│   └── node_modules\n│       └── foo\n└── B\n    └── node_modules\n        └── foo\n</code></pre>\n<p>最初，npm就简单通过依赖去递归安装包，A，B都依赖foo，那么就会有两份foo安装。为节省空间，采用了扁平化的node_modules。这样，foo会被提升到顶层，同一个包只会有一份。</p>\n<pre><code>node_modules\n├── A\n├── B\n└── foo\n</code></pre>\n<p>但是会带来的问题是引入混乱，扁平化结构可以直接引用foo，但实际上并没有直接指定依赖foo，而是有层级关系，导致了引入上的错乱。如果A,B都不依赖foo，包会报错。</p>\n<p>导致的问题：</p>\n<p>幻影依赖：项目代码引用的某个包没有直接定义在 <code>package.json</code>中，而是作为子依赖被某个包顺带安装了。代码里依赖幻影依赖的最大隐患是，对包的语义化控制不能穿透到其子包，也就是包 <code>a@patch</code>的改动可能意味着其子依赖包 <code>b@major</code><br>级别的 Break Change。（也就是说如果包改变了，那么被依赖的包就会破碎，出错）</p>\n<p>但还有一种更难以解决的幻影依赖问题，即用户在 Monorepo 项目根目录安装了某个包，这个包可能被某个子 Package 内的代码寻址到，要彻底解决这个问题，需要配合使用 Rush，在工程上通过依赖问题检测来彻底解决。</p>\n<h1 id=\"对比其优劣势\"><a href=\"#对比其优劣势\" class=\"headerlink\" title=\"对比其优劣势\"></a>对比其优劣势</h1><ul>\n<li>npm<ul>\n<li>node_modules扁平化结构</li>\n<li>支持workspace，大部分开发人员用npm也能很好的打包</li>\n<li>逐行安装（速度较慢）</li>\n<li>问题：幻影依赖，依赖分身</li>\n</ul>\n</li>\n<li>yarn<ul>\n<li>node_modules扁平化解构</li>\n<li>支持workspace，monorepo</li>\n<li>yarn主要为了解决语义版本控制而导致npm安装不确定的问题，由yarn.lock文件，不过npm也出了package-lock文件</li>\n<li>并行安装（速度较快）</li>\n<li>问题：幻影依赖，依赖分身</li>\n</ul>\n</li>\n<li>pnpm<ul>\n<li>pnpm采用内存寻址存储的方法，通过软硬链接引用依赖，实现node_modules非扁平化结构，</li>\n<li>支持workspace，monorepo，速度快，磁盘占用空间小（速度最快）</li>\n<li>通过内容寻址存储解决了幻影依赖，依赖分身的问题，安全性高。</li>\n<li>pnpm 的安装速度在大多数场景都比 npm 和 yarn 快 2 倍，节省的磁盘空间也更多。</li>\n<li>问题：<ul>\n<li>因为依赖源文件是安装在 store 中，调试依赖或 patch-package 给依赖打补丁也不太方便，可能会影响其他项目。</li>\n<li>由于 pnpm 创建的 node_modules 依赖软链接，因此在不支持软链接的环境中，无法使用 pnpm，比如 Electron 应用。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/d127a3607f604d40b532c12f8ca631a8.png\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "npm",
                "yarn",
                "pnpm",
                "Workspace",
                "Monorepo"
            ]
        },
        {
            "id": "http://example.com/2022/10/12/package.json-he-package-lock.json-xiang-jie/",
            "url": "http://example.com/2022/10/12/package.json-he-package-lock.json-xiang-jie/",
            "title": "package.json 和 package-lock.json详解",
            "date_published": "2022-10-12T12:27:14.217Z",
            "content_html": "<p>npm使用一个名为package.json的文件，用户可以通过npm install –save命令把项目里所有的依赖项保存在这个文件里。<br>npm遵循语义版本控制</p>\n<span id=\"more\"></span>\n<h1 id=\"语义版本控制是什么？\"><a href=\"#语义版本控制是什么？\" class=\"headerlink\" title=\"语义版本控制是什么？\"></a>语义版本控制是什么？</h1><p><code>1.5.4</code> 是版本号，其中</p>\n<ul>\n<li>1 是主版本号，代表的是不兼容的 API 修改（旧版本和新版本中有些方法不一样）</li>\n<li>5 是次版本号，代表的是向下兼容的功能性新增（旧版本和新版本中有些方法一样，但是新版本中又新增了这个方法）</li>\n<li>4 是修订号，代表的是向下兼容的问题修正（旧版本和新版本中有些方法一样，新版本中的方法修复了旧版本该方法部分场景下的bug）</li>\n</ul>\n<p><code>Semver</code> 规范：</p>\n<ul>\n<li>如果写入的是 <code>〜0.13.0</code>，则只更新补丁版本：即 0.13.1 可以，但 0.14.0 不可以。</li>\n<li>如果写入的是 <code>^0.13.0</code>，则要更新补丁版本和次版本：即 0.13.1、0.14.0、依此类推。</li>\n<li>如果写入的是 0.13.0，则始终使用确切的版本。</li>\n<li>还有一些不常用，就不展开介绍了  以vue脚手架为例：<br>  <img src=\"https://img-blog.csdnimg.cn/49831053514745b18bf930de2f1510c5.png\" alt=\"在这里插入图片描述\"></li>\n</ul>\n<p>   脚手架相关的库都采用只更新补丁的模式，其他的包都选择更新次版本号的功能，从而引入一些向下兼容的最新特性或是优化功能。</p>\n<p>补丁版本或次版本的更改还是具有很大的不确定性，可能引入缺陷。</p>\n<h1 id=\"锁定版本与-package-lock-json\"><a href=\"#锁定版本与-package-lock-json\" class=\"headerlink\" title=\"锁定版本与 package-lock.json\"></a>锁定版本与 package-lock.json</h1><p>锁定实际安装的脚本，即使package.json中脚本不一样，在锁定脚本之后，将此文件留在了git仓库，就可以保证原始项目和新初始项目安装的依赖是一样的。</p>\n<p>如果想要更新，使用npm update（风险较大，建议升级某个特定的包），遵循semver标准，并且更新之后锁定版本为最新，依旧锁定，</p>\n<p>1.为啥 <code>package-lock.json</code> 文件比 <code>package.json</code> 包大那么多？</p>\n<p><code>package-lock.json</code>不仅锁定了依赖包，还把依赖包的依赖都用套娃的方式锁住，</p>\n<p>有了 <code>package-lock.json</code>后，<code>package.json</code>的版本更新规则就不生效了，会优先读取 <code>package-lock.json</code>中锁定的包版本进行安装，保证你的代码库能顺利运行，不会因为依赖包频繁更新而频繁引发问题。</p>\n<h1 id=\"package-json各个属性的含义\"><a href=\"#package-json各个属性的含义\" class=\"headerlink\" title=\"package.json各个属性的含义\"></a>package.json各个属性的含义</h1><p><a href=\"https://blog.csdn.net/qq_34703156/article/details/121401990\">(2条消息) package.json 最全详解_HURRICANE_FAST的博客-CSDN博客_package.json</a></p>\n<p>package.json 文件是一个 JSON 对象</p>\n<p>当搭建一个新项目时，脚手架就初始化好了一个package.json 文件</p>\n<p><img src=\"https://img-blog.csdnimg.cn/4adf67b0d668494f8d24a7f1541719dd.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"必须属性\"><a href=\"#必须属性\" class=\"headerlink\" title=\"必须属性\"></a>必须属性</h2><p>name 和 version，它们都是必须的，如果没有，就无法正常执行 npm install 命令。npm 规定 package.json 文件是由名称和版本号作为唯一标识符的。</p>\n<h2 id=\"描述信息\"><a href=\"#描述信息\" class=\"headerlink\" title=\"描述信息\"></a>描述信息</h2><p>homepage是项目的主页地址，是一个string</p>\n<p>repository表示代码存放仓库地址</p>\n<p>bugs表示提交问题的地址</p>\n<h2 id=\"依赖配置\"><a href=\"#依赖配置\" class=\"headerlink\" title=\"依赖配置\"></a>依赖配置</h2><p><code>peerDependencies</code> 字段就是用来供插件指定其所需要的主工具的版本。<code>需要注意</code>，从 <code>npm 3.0</code> 版开始，peerDependencies 不再会默认安装了。（比如 A 模块是 B 模块的插件。用户安装的 B 模块是 1.0 版本，但是 A 插件只能和 2.0 版本的 B 模块一起使用。这时，用户要是将 1.0 版本的 B 的实例传给 A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果 A 和 B 一起安装，那么 B 必须是 2.0 模块。）</p>\n<p><code>optionalDependencies</code>中放的包在找不到包或安装包失败时，npm仍然能够运行。</p>\n<p><code>bundledDependencies</code>配置项是一个数组，数组里可以指定一些模块，这些模块将在这个包发布时被一起打包。需要注意，这个字段数组中的值必须是在 dependencies, devDependencies 两个里面声明过的包才行。</p>\n<p><code>engines</code> 字段中说明具体的版本号”engines”: {“node”: “&gt;=8.10.3 &lt;12.13.0”,”npm”: “&gt;=6.9.0”}。需要注意，engines 只是起一个说明的作用，即使用户安装的版本不符合要求，也不影响依赖包的安装。</p>\n<h2 id=\"脚本配置\"><a href=\"#脚本配置\" class=\"headerlink\" title=\"脚本配置\"></a>脚本配置</h2><p><code>scripts：</code>内置的脚本入口。这些脚本是命令行应用程序。可以通过调用 npm run XXX 或 yarn XXX 来运行它们，其中 XXX 是命令的名称。例如：npm run dev。我们可以为命令使用任何的名称，脚本也可以是任何操作。</p>\n<p><code>config</code> 字段用来配置 scripts 运行时的配置参数</p>\n<h2 id=\"文件-amp-目录\"><a href=\"#文件-amp-目录\" class=\"headerlink\" title=\"文件&amp;目录\"></a>文件&amp;目录</h2><p><code>main</code> 字段用来指定加载的入口文件，在 browser 和 Node 环境中都可以使用。如果我们将项目发布为 npm 包，那么当使用 require 导入 npm 包时，返回的就是 main 字段所列出的文件的 module.exports 属性。如果不指定该字段，默认是项目根目录下的 index.js。如果没找到，就会报错。</p>\n<p><code>browser</code> 字段可以定义 npm 包在 browser 环境下的入口文件。如果 npm 包只在 web 端使用，并且严禁在 server 端使用，使用 browser 来定义入口文件。</p>\n<p><code>module</code> 字段可以定义 npm 包的 ESM 规范的入口文件。需要注意，.js 文件是使用 commonJS 规范的语法 (require(‘xxx’))，.mjs 是用 ESM 规范的语法 (import ‘xxx’)。</p>\n<p><code>bin</code> 字段用来指定各个内部命令对应的可执行文件的位置。</p>\n<p>“bin”: {<br>        “someTool”: “./bin/someTool.js”                 //可执行文件的简称：可执行文件的路径<br>}<br>在使用到地址的地方可以直接使用简称</p>\n<p><code>directories</code> 字段用来规范项目的目录，这个属性实际上没有什么实际的作用，未来待定</p>\n<h2 id=\"发布配置\"><a href=\"#发布配置\" class=\"headerlink\" title=\"发布配置\"></a>发布配置</h2><p><code>private</code> 字段Boolean值，可以防止我们意外地将私有库发布到 npm 服务器。</p>\n<p><code>preferGlobal</code> 字段表示提示，当用户不把该模块安装为全局模块时，如果设置为 true 就会显示警告。</p>\n<p><code>publishConfig</code> 配置会在模块发布时生效，用于设置发布时一些配置项的集合。</p>\n<p>通常情况下，publishConfig 会配合 private 来使用，如果只想让模块发布到特定 npm 仓库</p>\n<p><code>os</code> 字段可以让我们设置该 npm 包可以在什么操作系统使用，不能再什么操作系统使用。”os” [“linux”]</p>\n<p><code>CPU</code> 可以更准确的限制用户的安装环境。</p>\n<p>“cpu” [“x64”, “AMD64”]   // 适用的cpu<br>“cpu” [“!arm”, “!mips”]  // 禁用的cpu</p>\n<p><code>license</code> 字段用于指定软件的开源协议，开源协议表述了其他人获得代码后拥有的权利。常见协议如下：</p>\n<ul>\n<li>MIT ：只要用户在项目副本中包含了版权声明和许可声明，他们就可以拿你的代码做任何想做的事情，你也无需承担任何责任。</li>\n<li>Apache ：类似于 MIT ，同时还包含了贡献者向用户提供专利授权相关的条款。</li>\n<li>GPL ：修改项目代码的用户再次分发源码或二进制代码时，必须公布他的相关修改。</li>\n</ul>\n<h2 id=\"第三方配置\"><a href=\"#第三方配置\" class=\"headerlink\" title=\"第三方配置\"></a>第三方配置</h2><p>详见上方链接文档</p>\n",
            "tags": [
                "npm"
            ]
        }
    ]
}